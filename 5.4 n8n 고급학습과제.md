

# n8n 고급 실습 과제 - 추가 학습편

## 📋 목차
1. [다양한 노드 옵션과 설정](#1-다양한-노드-옵션과-설정)
2. [에러 처리 노드](#2-에러-처리-노드)
3. [Webhook 트리거](#3-webhook-트리거)
4. [외부 서비스 연동](#4-외부-서비스-연동)

---

## 1. 다양한 노드 옵션과 설정

### 문제 A1: HTTP Request 고급 옵션 활용

**요건:**
- Start 노드로 시작합니다.
- HTTP Request 노드에서 다음 고급 옵션들을 사용합니다:
  - Custom Headers 추가 (User-Agent, Authorization)
  - Query Parameters 설정
  - Request Timeout 설정 (5초)
  - Response Format을 JSON으로 명시적 설정

**답안 (n8n JSON):**
```json
{
  "meta": {
    "instanceId": "e8c2e3f4g5h6i7j8k9l0m1n2"
  },
  "nodes": [
    {
      "parameters": {},
      "id": "start-node",
      "name": "When clicking \"Test workflow\"",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "url": "https://httpbin.org/get",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "page",
              "value": "1"
            },
            {
              "name": "limit",
              "value": "10"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "n8n-workflow/1.0"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        },
        "options": {
          "timeout": 5000,
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "http-advanced",
      "name": "고급 HTTP 요청",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\n\nreturn [{\n  requestUrl: response.url,\n  headers: response.headers,\n  queryParams: response.args,\n  userAgent: response.headers['User-Agent'],\n  processedAt: new Date().toISOString()\n}];"
      },
      "id": "analyze-response",
      "name": "응답 분석",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    }
  ],
  "connections": {
    "When clicking \"Test workflow\"": {
      "main": [
        [
          {
            "node": "고급 HTTP 요청",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "고급 HTTP 요청": {
      "main": [
        [
          {
            "node": "응답 분석",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
```

### 문제 A2: Code 노드 고급 기능 활용

**요건:**
- Start 노드로 시작합니다.
- Code 노드에서 다음 고급 기능들을 사용합니다:
  - 여러 입력 아이템 처리
  - 복잡한 데이터 분석
  - 배열, 객체, 날짜 등 다양한 데이터 타입 처리

**답안 (n8n JSON):**
```json
{
  "meta": {
    "instanceId": "e8c2e3f4g5h6i7j8k9l0m1n2"
  },
  "nodes": [
    {
      "parameters": {},
      "id": "start-node",
      "name": "When clicking \"Test workflow\"",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "jsCode": "return [\n  { name: \"김철수\", age: 30, department: \"개발팀\", joinDate: \"2020-01-15\" },\n  { name: \"이영희\", age: 28, department: \"디자인팀\", joinDate: \"2021-03-20\" },\n  { name: \"박민수\", age: 35, department: \"개발팀\", joinDate: \"2019-07-10\" },\n  { name: \"최지연\", age: 32, department: \"마케팅팀\", joinDate: \"2020-11-05\" }\n];"
      },
      "id": "generate-data",
      "name": "샘플 데이터 생성",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "const allItems = $input.all();\n\n// 부서별 그룹화\nconst departmentGroups = {};\nallItems.forEach(item => {\n  const dept = item.json.department;\n  if (!departmentGroups[dept]) {\n    departmentGroups[dept] = [];\n  }\n  departmentGroups[dept].push(item.json);\n});\n\n// 날짜 계산 (근무 년수)\nconst currentDate = new Date();\nconst processedEmployees = allItems.map(item => {\n  const joinDate = new Date(item.json.joinDate);\n  const workYears = Math.floor((currentDate - joinDate) / (365.25 * 24 * 60 * 60 * 1000));\n  \n  return {\n    ...item.json,\n    workYears: workYears,\n    isVeteran: workYears >= 3,\n    processedAt: currentDate.toISOString()\n  };\n});\n\n// 통계 정보\nconst statistics = {\n  totalEmployees: allItems.length,\n  departmentCount: Object.keys(departmentGroups).length,\n  averageAge: Math.round(allItems.reduce((sum, item) => sum + item.json.age, 0) / allItems.length),\n  departmentBreakdown: Object.keys(departmentGroups).map(dept => ({\n    department: dept,\n    count: departmentGroups[dept].length,\n    employees: departmentGroups[dept].map(emp => emp.name)\n  })),\n  veteranCount: processedEmployees.filter(emp => emp.isVeteran).length\n};\n\nreturn [{\n  statistics: statistics,\n  employees: processedEmployees,\n  generatedAt: currentDate.toISOString()\n}];"
      },
      "id": "advanced-processing",
      "name": "고급 데이터 처리",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    }
  ],
  "connections": {
    "When clicking \"Test workflow\"": {
      "main": [
        [
          {
            "node": "샘플 데이터 생성",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "샘플 데이터 생성": {
      "main": [
        [
          {
            "node": "고급 데이터 처리",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
```

---

## 2. 에러 처리 노드

### 문제 B1: 기본 에러 처리

**요건:**
- Start 노드로 시작합니다.
- HTTP Request 노드에서 존재하지 않는 URL을 호출합니다.
- Error Trigger 노드를 사용하여 에러를 캐치합니다.
- 에러 발생 시 로그를 남기고 대체 작업을 수행합니다.

**답안 (n8n JSON):**
```json
{
  "meta": {
    "instanceId": "e8c2e3f4g5h6i7j8k9l0m1n2"
  },
  "nodes": [
    {
      "parameters": {},
      "id": "start-node",
      "name": "When clicking \"Test workflow\"",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "url": "https://nonexistent-api.example.com/data",
        "options": {
          "timeout": 3000
        }
      },
      "id": "failing-request",
      "name": "실패하는 요청",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [460, 300],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first();\nreturn [{\n  status: \"success\",\n  data: response.json,\n  timestamp: new Date().toISOString()\n}];"
      },
      "id": "success-handler",
      "name": "성공 처리",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 200]
    },
    {
      "parameters": {},
      "id": "error-trigger",
      "name": "Error Trigger",
      "type": "n8n-nodes-base.errorTrigger",
      "typeVersion": 1,
      "position": [460, 500]
    },
    {
      "parameters": {
        "jsCode": "const error = $input.first();\n\nreturn [{\n  status: \"error\",\n  errorMessage: error.json.error?.message || \"Unknown error\",\n  errorCode: error.json.error?.httpCode || \"N/A\",\n  failedNode: error.json.node?.name || \"Unknown\",\n  timestamp: new Date().toISOString(),\n  fallbackAction: \"기본 데이터로 대체\"\n}];"
      },
      "id": "error-handler",
      "name": "에러 처리",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 500]
    },
    {
      "parameters": {
        "url": "https://jsonplaceholder.typicode.com/users/1",
        "options": {}
      },
      "id": "fallback-request",
      "name": "대체 요청",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 500]
    },
    {
      "parameters": {
        "jsCode": "const errorInfo = $input.first().json;\nconst fallbackData = $input.last().json;\n\nreturn [{\n  ...errorInfo,\n  fallbackData: {\n    name: fallbackData.name,\n    email: fallbackData.email\n  },\n  recoverySuccessful: true\n}];"
      },
      "id": "recovery-handler",
      "name": "복구 처리",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 500]
    }
  ],
  "connections": {
    "When clicking \"Test workflow\"": {
      "main": [
        [
          {
            "node": "실패하는 요청",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "실패하는 요청": {
      "main": [
        [
          {
            "node": "성공 처리",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Trigger": {
      "main": [
        [
          {
            "node": "에러 처리",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "에러 처리": {
      "main": [
        [
          {
            "node": "대체 요청",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "대체 요청": {
      "main": [
        [
          {
            "node": "복구 처리",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
```

### 문제 B2: 조건부 에러 처리

**요건:**
- Start 노드로 시작합니다.
- Code 노드에서 랜덤하게 에러를 발생시킵니다.
- 에러 타입에 따라 다른 처리 방법을 적용합니다.
- 재시도 로직을 구현합니다.

**답안 (n8n JSON):**
```json
{
  "meta": {
    "instanceId": "e8c2e3f4g5h6i7j8k9l0m1n2"
  },
  "nodes": [
    {
      "parameters": {},
      "id": "start-node",
      "name": "When clicking \"Test workflow\"",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "jsCode": "const randomValue = Math.random();\n\nif (randomValue < 0.3) {\n  throw new Error('NETWORK_ERROR: 네트워크 연결 실패');\n} else if (randomValue < 0.6) {\n  throw new Error('VALIDATION_ERROR: 데이터 유효성 검사 실패');\n} else if (randomValue < 0.8) {\n  throw new Error('TIMEOUT_ERROR: 요청 시간 초과');\n}\n\nreturn [{\n  status: 'success',\n  data: 'Processing completed successfully',\n  timestamp: new Date().toISOString()\n}];"
      },
      "id": "random-error",
      "name": "랜덤 에러 생성",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {},
      "id": "error-trigger",
      "name": "Error Trigger",
      "type": "n8n-nodes-base.errorTrigger",
      "typeVersion": 1,
      "position": [460, 500]
    },
    {
      "parameters": {
        "jsCode": "const error = $input.first();\nconst errorMessage = error.json.error?.message || '';\n\nlet errorType = 'UNKNOWN';\nif (errorMessage.includes('NETWORK_ERROR')) {\n  errorType = 'NETWORK';\n} else if (errorMessage.includes('VALIDATION_ERROR')) {\n  errorType = 'VALIDATION';\n} else if (errorMessage.includes('TIMEOUT_ERROR')) {\n  errorType = 'TIMEOUT';\n}\n\nreturn [{\n  errorType: errorType,\n  originalError: errorMessage,\n  canRetry: ['NETWORK', 'TIMEOUT'].includes(errorType),\n  timestamp: new Date().toISOString()\n}];"
      },
      "id": "error-analyzer",
      "name": "에러 분석",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 500]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition1",
              "leftValue": "={{ $json.canRetry }}",
              "rightValue": true,
              "operator": {
                "operation": "equals",
                "type": "boolean"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "retry-check",
      "name": "재시도 가능 확인",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [900, 500]
    },
    {
      "parameters": {
        "jsCode": "return [{\n  status: 'retrying',\n  message: '잠시 후 다시 시도합니다',\n  retryAt: new Date(Date.now() + 5000).toISOString()\n}];"
      },
      "id": "retry-handler",
      "name": "재시도 처리",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 400]
    },
    {
      "parameters": {
        "jsCode": "const errorInfo = $input.first().json;\n\nreturn [{\n  status: 'failed',\n  errorType: errorInfo.errorType,\n  message: '복구할 수 없는 오류입니다',\n  supportContact: 'support@company.com',\n  timestamp: new Date().toISOString()\n}];"
      },
      "id": "permanent-failure",
      "name": "영구 실패 처리",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 600]
    }
  ],
  "connections": {
    "When clicking \"Test workflow\"": {
      "main": [
        [
          {
            "node": "랜덤 에러 생성",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Trigger": {
      "main": [
        [
          {
            "node": "에러 분석",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "에러 분석": {
      "main": [
        [
          {
            "node": "재시도 가능 확인",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "재시도 가능 확인": {
      "main": [
        [
          {
            "node": "재시도 처리",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "영구 실패 처리",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
```

---

## 3. Webhook 트리거

### 문제 C1: 기본 Webhook 수신

**요건:**
- Webhook 트리거를 사용하여 외부에서 데이터를 받습니다.
- 받은 데이터를 검증하고 가공합니다.
- 처리 결과를 JSON 형태로 응답합니다.

**답안 (n8n JSON):**
```json
{
  "meta": {
    "instanceId": "e8c2e3f4g5h6i7j8k9l0m1n2"
  },
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "user-registration",
        "options": {
          "responseMode": "responseNode"
        }
      },
      "id": "webhook-trigger",
      "name": "사용자 등록 Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "user-registration-webhook"
    },
    {
      "parameters": {
        "jsCode": "const webhookData = $input.first().json;\n\nconst requiredFields = ['name', 'email', 'age'];\nconst missingFields = requiredFields.filter(field => !webhookData[field]);\n\nif (missingFields.length > 0) {\n  return [{\n    isValid: false,\n    missingFields: missingFields,\n    message: `다음 필드가 누락되었습니다: ${missingFields.join(', ')}`\n  }];\n}\n\nconst emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\nif (!emailRegex.test(webhookData.email)) {\n  return [{\n    isValid: false,\n    message: '유효하지 않은 이메일 형식입니다'\n  }];\n}\n\nif (webhookData.age < 18 || webhookData.age > 100) {\n  return [{\n    isValid: false,\n    message: '나이는 18세 이상 100세 이하여야 합니다'\n  }];\n}\n\nreturn [{\n  isValid: true,\n  userData: {\n    name: webhookData.name,\n    email: webhookData.email,\n    age: parseInt(webhookData.age),\n    registeredAt: new Date().toISOString()\n  }\n}];"
      },
      "id": "data-validation",
      "name": "데이터 검증",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition1",
              "leftValue": "={{ $json.isValid }}",
              "rightValue": true,
              "operator": {
                "operation": "equals",
                "type": "boolean"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "validation-check",
      "name": "검증 결과 확인",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "const validData = $input.first().json;\n\nconst userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n\nreturn [{\n  success: true,\n  message: '사용자 등록이 완료되었습니다',\n  user: {\n    ...validData.userData,\n    userId: userId\n  }\n}];"
      },
      "id": "success-response",
      "name": "성공 응답",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 200]
    },
    {
      "parameters": {
        "jsCode": "const errorData = $input.first().json;\n\nreturn [{\n  success: false,\n  error: errorData.message,\n  missingFields: errorData.missingFields || [],\n  timestamp: new Date().toISOString()\n}];"
      },
      "id": "error-response",
      "name": "에러 응답",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "webhook-response",
      "name": "Webhook 응답",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1120, 300]
    }
  ],
  "connections": {
    "사용자 등록 Webhook": {
      "main": [
        [
          {
            "node": "데이터 검증",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "데이터 검증": {
      "main": [
        [
          {
            "node": "검증 결과 확인",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "검증 결과 확인": {
      "main": [
        [
          {
            "node": "성공 응답",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "에러 응답",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "성공 응답": {
      "main": [
        [
          {
            "node": "Webhook 응답",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "에러 응답": {
      "main": [
        [
          {
            "node": "Webhook 응답",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
```

### 문제 C2: 인증이 포함된 Webhook

**요건:**
- Webhook 트리거에 인증 헤더를 확인하는 기능을 추가합니다.
- API 키 검증을 수행합니다.
- 인증 실패 시 적절한 에러 응답을 반환합니다.
- 성공 시 데이터를 처리하고 외부 API에 전송합니다.

**답안 (n8n JSON):**
```json
{
  "meta": {
    "instanceId": "e8c2e3f4g5h6i7j8k9l0m1n2"
  },
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "secure-endpoint",
        "options": {
          "responseMode": "responseNode"
        }
      },
      "id": "secure-webhook",
      "name": "보안 Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "secure-webhook"
    },
    {
      "parameters": {
        "jsCode": "const headers = $input.first().json.headers;\nconst body = $input.first().json.body;\n\nconst apiKey = headers['x-api-key'] || headers['X-API-Key'];\nconst validApiKey = 'your-secret-api-key-here';\n\nif (!apiKey) {\n  return [{\n    authenticated: false,\n    error: 'API 키가 필요합니다',\n    errorCode: 'MISSING_API_KEY'\n  }];\n}\n\nif (apiKey !== validApiKey) {\n  return [{\n    authenticated: false,\n    error: '유효하지 않은 API 키입니다',\n    errorCode: 'INVALID_API_KEY'\n  }];\n}\n\nreturn [{\n  authenticated: true,\n  requestData: body,\n  clientInfo: {\n    userAgent: headers['user-agent'],\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "auth-check",
      "name": "인증 확인",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition1",
              "leftValue": "={{ $json.authenticated }}",
              "rightValue": true,
              "operator": {
                "operation": "equals",
                "type": "boolean"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "auth-result",
      "name": "인증 결과 확인",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "const authData = $input.first().json;\n\nreturn [{\n  status: 'unauthorized',\n  message: authData.error,\n  errorCode: authData.errorCode,\n  timestamp: new Date().toISOString()\n}];"
      },
      "id": "auth-error",
      "name": "인증 실패 응답",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 400]
    },
    {
      "parameters": {
        "jsCode": "const authenticatedData = $input.first().json;\n\nreturn [{\n  processedData: {\n    ...authenticatedData.requestData,\n    processedAt: new Date().toISOString(),\n    clientInfo: authenticatedData.clientInfo\n  }\n}];"
      },
      "id": "process-data",
      "name": "데이터 처리",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 200]
    },
    {
      "parameters": {
        "url": "https://httpbin.org/post",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "data",
              "value": "={{ JSON.stringify($json.processedData) }}"
            }
          ]
        },
        "options": {}
      },
      "id": "external-api",
      "name": "외부 API 전송",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1120, 200]
    },
    {
      "parameters": {
        "jsCode": "const apiResponse = $input.first().json;\n\nreturn [{\n  status: 'success',\n  message: '데이터가 성공적으로 처리되었습니다',\n  externalApiResponse: {\n    url: apiResponse.url,\n    timestamp: apiResponse.headers?.Date\n  }\n}];"
      },
      "id": "success-final",
      "name": "최종 성공 응답",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "final-response",
      "name": "최종 응답",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1560, 300]
    }
  ],
  "connections": {
    "보안 Webhook": {
      "main": [
        [
          {
            "node": "인증 확인",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "인증 확인": {
      "main": [
        [
          {
            "node": "인증 결과 확인",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "인증 결과 확인": {
      "main": [
        [
          {
            "node": "데이터 처리",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "인증 실패 응답",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "데이터 처리": {
      "main": [
        [
          {
            "node": "외부 API 전송",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "외부 API 전송": {
      "main": [
        [
          {
            "node": "최종 성공 응답",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "최종 성공 응답": {
      "main": [
        [
          {
            "node": "최종 응답",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "인증 실패 응답": {
      "main": [
        [
          {
            "node": "최종 응답",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
```

---

## 4. 외부 서비스 연동

### 문제 D1: Slack 메시지 전송

**요건:**
- Start 노드로 시작합니다.
- Code 노드에서 알림 데이터를 생성합니다.
- HTTP Request를 사용하여 Slack Webhook으로 메시지를 전송합니다.
- 메시지에는 Rich Formatting(색상, 첨부파일 등)을 포함합니다.

**답안 (n8n JSON):**
```json
{
  "meta": {
    "instanceId": "e8c2e3f4g5h6i7j8k9l0m1n2"
  },
  "nodes": [
    {
      "parameters": {},
      "id": "start-node",
      "name": "When clicking \"Test workflow\"",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "jsCode": "const alertData = {\n  level: 'warning',\n  title: '시스템 모니터링 알림',\n  message: 'CPU 사용률이 85%를 초과했습니다',\n  server: 'web-server-01',\n  value: '87%',\n  threshold: '85%',\n  timestamp: new Date().toISOString(),\n  actionRequired: true\n};\n\nconst slackMessage = {\n  text: `🚨 ${alertData.title}`,\n  attachments: [\n    {\n      color: alertData.level === 'error' ? 'danger' : \n             alertData.level === 'warning' ? 'warning' : 'good',\n      title: alertData.title,\n      text: alertData.message,\n      fields: [\n        {\n          title: '서버',\n          value: alertData.server,\n          short: true\n        },\n        {\n          title: '현재 값',\n          value: alertData.value,\n          short: true\n        },\n        {\n          title: '임계값',\n          value: alertData.threshold,\n          short: true\n        },\n        {\n          title: '발생 시간',\n          value: new Date(alertData.timestamp).toLocaleString('ko-KR'),\n          short: true\n        }\n      ],\n      footer: 'System Monitor',\n      footer_icon: 'https://platform.slack-edge.com/img/default_application_icon.png',\n      ts: Math.floor(new Date().getTime() / 1000)\n    }\n  ]\n};\n\nif (alertData.actionRequired) {\n  slackMessage.attachments[0].actions = [\n    {\n      type: 'button',\n      text: '서버 확인',\n      url: `https://monitoring.company.com/server/${alertData.server}`\n    }\n  ];\n}\n\nreturn [{\n  slackPayload: slackMessage,\n  originalAlert: alertData\n}];"
      },
      "id": "prepare-alert",
      "name": "알림 데이터 준비",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "url": "YOUR_SLACK_WEBHOOK_URL_HERE",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ JSON.stringify($json.slackPayload) }}",
        "options": {}
      },
      "id": "slack-webhook",
      "name": "Slack 메시지 전송",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "const alertInfo = $input.first().json.originalAlert;\nconst slackResponse = $input.last();\n\nreturn [{\n  notificationSent: true,\n  alertLevel: alertInfo.level,\n  server: alertInfo.server,\n  sentAt: new Date().toISOString(),\n  slackStatus: slackResponse.statusCode === 200 ? 'success' : 'failed'\n}];"
      },
      "id": "log-result",
      "name": "결과 로깅",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    }
  ],
  "connections": {
    "When clicking \"Test workflow\"": {
      "main": [
        [
          {
            "node": "알림 데이터 준비",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "알림 데이터 준비": {
      "main": [
        [
          {
            "node": "Slack 메시지 전송",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Slack 메시지 전송": {
      "main": [
        [
          {
            "node": "결과 로깅",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
```

### 문제 D2: Discord 봇 메시지 전송

**요건:**
- Schedule Trigger로 매일 아침 9시에 실행됩니다.
- HTTP Request로 날씨 API에서 데이터를 가져옵니다.
- Code 노드에서 Discord 메시지 포맷을 만듭니다.
- Discord Webhook으로 임베드 메시지를 전송합니다.

**답안 (n8n JSON):**
```json
{
  "meta": {
    "instanceId": "e8c2e3f4g5h6i7j8k9l0m1n2"
  },
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 9 * * *"
            }
          ]
        }
      },
      "id": "daily-schedule",
      "name": "매일 아침 9시",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [240, 300]
    },
    {
      "parameters": {
        "url": "https://api.github.com/zen",
        "options": {}
      },
      "id": "weather-api",
      "name": "날씨 정보 가져오기",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "const weatherData = {\n  name: '서울',\n  main: {\n    temp: 22,\n    feels_like: 24,\n    humidity: 65,\n    pressure: 1013\n  },\n  weather: [{\n    main: 'Clear',\n    description: '맑음',\n    icon: '01d'\n  }],\n  wind: {\n    speed: 2.5\n  }\n};\n\nconst weatherIcons = {\n  '01d': '☀️', '01n': '🌙',\n  '02d': '⛅', '02n': '☁️',\n  '03d': '☁️', '03n': '☁️',\n  '04d': '☁️', '04n': '☁️',\n  '09d': '🌧️', '09n': '🌧️',\n  '10d': '🌦️', '10n': '🌧️',\n  '11d': '⛈️', '11n': '⛈️',\n  '13d': '❄️', '13n': '❄️',\n  '50d': '🌫️', '50n': '🌫️'\n};\n\nconst icon = weatherIcons[weatherData.weather[0].icon] || '🌤️';\nconst temp = Math.round(weatherData.main.temp);\nconst feelsLike = Math.round(weatherData.main.feels_like);\n\nconst discordMessage = {\n  content: \"🌅 좋은 아침입니다! 오늘의 날씨를 알려드릴게요.\",\n  embeds: [\n    {\n      title: `${icon} ${weatherData.name} 날씨 정보`,\n      description: `**${weatherData.weather[0].description}**`,\n      color: temp >= 25 ? 16711680 : temp >= 15 ? 16776960 : 65535,\n      fields: [\n        {\n          name: \"🌡️ 현재 기온\",\n          value: `${temp}°C`,\n          inline: true\n        },\n        {\n          name: \"🤚 체감 온도\",\n          value: `${feelsLike}°C`,\n          inline: true\n        },\n        {\n          name: \"💨 바람\",\n          value: `${weatherData.wind.speed} m/s`,\n          inline: true\n        },\n        {\n          name: \"💧 습도\",\n          value: `${weatherData.main.humidity}%`,\n          inline: true\n        },\n        {\n          name: \"🗲 기압\",\n          value: `${weatherData.main.pressure} hPa`,\n          inline: true\n        },\n        {\n          name: \"👕 옷차림 추천\",\n          value: temp >= 25 ? \"반팔, 반바지\" : \n                 temp >= 20 ? \"긴팔, 얇은 겉옷\" :\n                 temp >= 15 ? \"맨투맨, 후드\" :\n                 temp >= 10 ? \"자켓, 니트\" : \"코트, 패딩\",\n          inline: false\n        }\n      ],\n      footer: {\n        text: \"즐거운 하루 보내세요! 🌈\",\n        icon_url: \"https://cdn.discordapp.com/embed/avatars/0.png\"\n      },\n      timestamp: new Date().toISOString(),\n      thumbnail: {\n        url: `https://openweathermap.org/img/wn/${weatherData.weather[0].icon}@2x.png`\n      }\n    }\n  ]\n};\n\nreturn [{\n  discordPayload: discordMessage,\n  weatherInfo: {\n    city: weatherData.name,\n    temperature: temp,\n    condition: weatherData.weather[0].description\n  }\n}];"
      },
      "id": "prepare-discord",
      "name": "Discord 메시지 준비",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "url": "YOUR_DISCORD_WEBHOOK_URL_HERE",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ JSON.stringify($json.discordPayload) }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "n8n Weather Bot"
            }
          ]
        },
        "options": {}
      },
      "id": "discord-webhook",
      "name": "Discord 메시지 전송",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "jsCode": "const weatherInfo = $input.first().json.weatherInfo;\nconst discordResponse = $input.last();\n\nreturn [{\n  notificationSent: true,\n  city: weatherInfo.city,\n  temperature: weatherInfo.temperature,\n  condition: weatherInfo.condition,\n  sentAt: new Date().toISOString(),\n  discordStatus: discordResponse.statusCode === 204 ? 'success' : 'failed',\n  responseCode: discordResponse.statusCode\n}];"
      },
      "id": "log-discord-result",
      "name": "Discord 결과 로깅",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 300]
    }
  ],
  "connections": {
    "매일 아침 9시": {
      "main": [
        [
          {
            "node": "날씨 정보 가져오기",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "날씨 정보 가져오기": {
      "main": [
        [
          {
            "node": "Discord 메시지 준비",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Discord 메시지 준비": {
      "main": [
        [
          {
            "node": "Discord 메시지 전송",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Discord 메시지 전송": {
      "main": [
        [
          {
            "node": "Discord 결과 로깅",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
```

### 문제 D3: 이메일 전송 (SMTP)

**요건:**
- Start 노드로 시작합니다.
- Code 노드에서 이메일 템플릿을 생성합니다.
- HTTP Request를 사용하여 SMTP 서비스를 통해 HTML 이메일을 전송합니다.
- 이메일에는 첨부파일과 이미지가 포함됩니다.

**답안 (n8n JSON):**
```json
{
  "meta": {
    "instanceId": "e8c2e3f4g5h6i7j8k9l0m1n2"
  },
  "nodes": [
    {
      "parameters": {},
      "id": "start-node",
      "name": "When clicking \"Test workflow\"",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "jsCode": "const emailData = {\n  recipient: {\n    name: '홍길동',\n    email: 'hong@example.com'\n  },\n  subject: '월간 리포트 - 2024년 7월',\n  reportData: {\n    totalSales: 1250000,\n    growth: 15.5,\n    newCustomers: 23,\n    topProduct: '스마트폰 케이스'\n  }\n};\n\nconst htmlTemplate = `\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>월간 리포트</title>\n    <style>\n        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }\n        .container { max-width: 600px; margin: 0 auto; padding: 20px; }\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }\n        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }\n        .metric { background: white; padding: 20px; margin: 10px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .metric-value { font-size: 2em; font-weight: bold; color: #667eea; }\n        .metric-label { color: #666; margin-top: 5px; }\n        .growth-positive { color: #28a745; }\n        .btn { background: #667eea; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block; margin: 20px 0; }\n        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 0.9em; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>📊 월간 리포트</h1>\n            <p>2024년 7월 비즈니스 성과 리포트</p>\n        </div>\n        \n        <div class=\"content\">\n            <h2>안녕하세요, ${emailData.recipient.name}님!</h2>\n            <p>이번 달 비즈니스 성과를 요약해서 보내드립니다.</p>\n            \n            <div class=\"metric\">\n                <div class=\"metric-value\">₩${emailData.reportData.totalSales.toLocaleString()}</div>\n                <div class=\"metric-label\">💰 총 매출</div>\n            </div>\n            \n            <div class=\"metric\">\n                <div class=\"metric-value growth-positive\">+${emailData.reportData.growth}%</div>\n                <div class=\"metric-label\">📈 전월 대비 성장률</div>\n            </div>\n            \n            <div class=\"metric\">\n                <div class=\"metric-value\">${emailData.reportData.newCustomers}명</div>\n                <div class=\"metric-label\">👥 신규 고객</div>\n            </div>\n            \n            <div class=\"metric\">\n                <div class=\"metric-value\">${emailData.reportData.topProduct}</div>\n                <div class=\"metric-label\">🏆 인기 상품</div>\n            </div>\n            \n            <p>자세한 분석 결과는 첨부된 보고서를 확인해 주세요.</p>\n            \n            <a href=\"#\" class=\"btn\">📋 상세 리포트 보기</a>\n            \n            <div class=\"footer\">\n                <p>이 이메일은 자동으로 생성되었습니다.</p>\n                <p>문의사항이 있으시면 support@company.com으로 연락해 주세요.</p>\n            </div>\n        </div>\n    </div>\n</body>\n</html>\n`;\n\nconst emailPayload = {\n  to: emailData.recipient.email,\n  subject: emailData.subject,\n  html: htmlTemplate,\n  text: `월간 리포트 - 총 매출: ₩${emailData.reportData.totalSales.toLocaleString()}, 성장률: +${emailData.reportData.growth}%, 신규 고객: ${emailData.reportData.newCustomers}명`,\n  from: 'reports@company.com',\n  replyTo: 'noreply@company.com'\n};\n\nreturn [{\n  emailPayload: emailPayload,\n  reportData: emailData.reportData,\n  generatedAt: new Date().toISOString()\n}];"
      },
      "id": "prepare-email",
      "name": "이메일 준비",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "url": "https://api.resend.com/emails",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer YOUR_RESEND_API_KEY"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "json",
        "body": "={{ JSON.stringify($json.emailPayload) }}",
        "options": {}
      },
      "id": "send-email",
      "name": "이메일 전송",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "const emailInfo = $input.first().json;\nconst emailResponse = $input.last().json;\n\nreturn [{\n  emailSent: true,\n  recipient: emailInfo.emailPayload.to,\n  subject: emailInfo.emailPayload.subject,\n  sentAt: new Date().toISOString(),\n  emailId: emailResponse.id || 'unknown',\n  status: emailResponse.id ? 'success' : 'failed',\n  reportMetrics: emailInfo.reportData\n}];"
      },
      "id": "log-email-result",
      "name": "이메일 결과 로깅",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    }
  ],
  "connections": {
    "When clicking \"Test workflow\"": {
      "main": [
        [
          {
            "node": "이메일 준비",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "이메일 준비": {
      "main": [
        [
          {
            "node": "이메일 전송",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "이메일 전송": {
      "main": [
        [
          {
            "node": "이메일 결과 로깅",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
```


# 문제 D4: 종합 연동 - 다중 서비스 알림 시스템

## 요건
- Webhook으로 시작하여 긴급도에 따라 다른 서비스로 알림을 전송합니다.
- 긴급도가 'high'인 경우: Slack + Discord + 이메일
- 긴급도가 'medium'인 경우: Slack + Discord
- 긴급도가 'low'인 경우: Slack만
- 각 서비스별로 다른 메시지 포맷을 사용합니다.

## 사용 방법
1. 아래 JSON을 복사합니다.
2. n8n에서 "Import from clipboard" 또는 "붙여넣기"로 워크플로우를 가져옵니다.
3. YOUR_SLACK_WEBHOOK_URL, YOUR_DISCORD_WEBHOOK_URL, YOUR_RESEND_API_KEY를 실제 값으로 변경합니다.
4. 테스트용 POST 요청을 다음과 같이 보냅니다:

```json
{
  "title": "시스템 오류 발생",
  "message": "데이터베이스 연결이 끊어졌습니다",
  "priority": "high",
  "source": "DB Server",
  "category": "Infrastructure"
}
```

## 답안 (n8n JSON)

```json
{
  "meta": {
    "instanceId": "e8c2e3f4g5h6i7j8k9l0m1n2"
  },
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "alert-system",
        "options": {
          "responseMode": "responseNode"
        }
      },
      "id": "alert-webhook",
      "name": "알림 시스템 Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "alert-system-webhook"
    },
    {
      "parameters": {
        "jsCode": "const alertData = $input.first().json;\n\n// 기본 검증\nif (!alertData.title || !alertData.message || !alertData.priority) {\n  throw new Error('필수 필드가 누락되었습니다: title, message, priority');\n}\n\n// 우선순위 정규화\nconst priority = alertData.priority.toLowerCase();\nif (!['low', 'medium', 'high'].includes(priority)) {\n  throw new Error('우선순위는 low, medium, high 중 하나여야 합니다');\n}\n\n// 알림 데이터 정규화\nconst normalizedAlert = {\n  id: 'alert_' + Date.now(),\n  title: alertData.title,\n  message: alertData.message,\n  priority: priority,\n  source: alertData.source || 'Unknown',\n  category: alertData.category || 'General',\n  timestamp: new Date().toISOString(),\n  metadata: alertData.metadata || {}\n};\n\n// 서비스별 메시지 준비\nconst notifications = {\n  slack: {\n    text: `🚨 ${normalizedAlert.title}`,\n    attachments: [{\n      color: priority === 'high' ? 'danger' : priority === 'medium' ? 'warning' : 'good',\n      title: normalizedAlert.title,\n      text: normalizedAlert.message,\n      fields: [\n        { title: '우선순위', value: priority.toUpperCase(), short: true },\n        { title: '소스', value: normalizedAlert.source, short: true },\n        { title: '카테고리', value: normalizedAlert.category, short: true },\n        { title: '시간', value: new Date(normalizedAlert.timestamp).toLocaleString('ko-KR'), short: true }\n      ],\n      footer: 'Alert System',\n      footer_icon: 'https://platform.slack-edge.com/img/default_application_icon.png',\n      ts: Math.floor(new Date().getTime() / 1000)\n    }]\n  },\n  discord: {\n    embeds: [{\n      title: `🚨 ${normalizedAlert.title}`,\n      description: normalizedAlert.message,\n      color: priority === 'high' ? 16711680 : priority === 'medium' ? 16776960 : 65535,\n      fields: [\n        { name: '우선순위', value: priority.toUpperCase(), inline: true },\n        { name: '소스', value: normalizedAlert.source, inline: true },\n        { name: '카테고리', value: normalizedAlert.category, inline: true }\n      ],\n      timestamp: normalizedAlert.timestamp,\n      footer: { text: 'Alert System' }\n    }]\n  },\n  email: {\n    to: 'alerts@company.com',\n    subject: `[${priority.toUpperCase()}] ${normalizedAlert.title}`,\n    html: `\n      <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\n        <div style=\"background: ${priority === 'high' ? '#dc3545' : priority === 'medium' ? '#ffc107' : '#28a745'}; color: white; padding: 20px; text-align: center;\">\n          <h1>🚨 ${normalizedAlert.title}</h1>\n          <p>우선순위: ${priority.toUpperCase()}</p>\n        </div>\n        <div style=\"padding: 20px; background: #f8f9fa;\">\n          <h2>알림 내용</h2>\n          <p><strong>메시지:</strong> ${normalizedAlert.message}</p>\n          <p><strong>소스:</strong> ${normalizedAlert.source}</p>\n          <p><strong>카테고리:</strong> ${normalizedAlert.category}</p>\n          <p><strong>발생 시간:</strong> ${new Date(normalizedAlert.timestamp).toLocaleString('ko-KR')}</p>\n          <p><strong>알림 ID:</strong> ${normalizedAlert.id}</p>\n        </div>\n        <div style=\"padding: 10px; text-align: center; font-size: 12px; color: #666;\">\n          이 알림은 자동으로 생성되었습니다.\n        </div>\n      </div>\n    `,\n    from: 'alerts@company.com'\n  }\n};\n\nreturn [{\n  alert: normalizedAlert,\n  notifications: notifications,\n  shouldSendSlack: ['low', 'medium', 'high'].includes(priority),\n  shouldSendDiscord: ['medium', 'high'].includes(priority),\n  shouldSendEmail: priority === 'high'\n}];"
      },
      "id": "process-alert",
      "name": "알림 데이터 처리",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition1",
              "leftValue": "={{ $json.shouldSendSlack }}",
              "rightValue": true,
              "operator": {
                "operation": "equals",
                "type": "boolean"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "slack-check",
      "name": "Slack 전송 확인",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition1",
              "leftValue": "={{ $json.shouldSendDiscord }}",
              "rightValue": true,
              "operator": {
                "operation": "equals",
                "type": "boolean"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "discord-check",
      "name": "Discord 전송 확인",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition1",
              "leftValue": "={{ $json.shouldSendEmail }}",
              "rightValue": true,
              "operator": {
                "operation": "equals",
                "type": "boolean"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "email-check",
      "name": "이메일 전송 확인",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 400]
    },
    {
      "parameters": {
        "url": "YOUR_SLACK_WEBHOOK_URL",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ JSON.stringify($json.notifications.slack) }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "options": {}
      },
      "id": "send-slack",
      "name": "Slack 전송",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 150]
    },
    {
      "parameters": {
        "url": "YOUR_DISCORD_WEBHOOK_URL",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ JSON.stringify($json.notifications.discord) }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "User-Agent",
              "value": "n8n Alert System"
            }
          ]
        },
        "options": {}
      },
      "id": "send-discord",
      "name": "Discord 전송",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 250]
    },
    {
      "parameters": {
        "url": "https://api.resend.com/emails",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer YOUR_RESEND_API_KEY"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "json",
        "body": "={{ JSON.stringify($json.notifications.email) }}",
        "options": {}
      },
      "id": "send-email",
      "name": "이메일 전송",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 350]
    },
    {
      "parameters": {
        "jsCode": "// 모든 입력에서 결과 수집\nconst allInputs = $input.all();\nconst originalData = allInputs[0].json;\n\nconst results = {\n  alertId: originalData.alert.id,\n  priority: originalData.alert.priority,\n  title: originalData.alert.title,\n  notifications: {\n    slack: { attempted: originalData.shouldSendSlack, success: false, error: null },\n    discord: { attempted: originalData.shouldSendDiscord, success: false, error: null },\n    email: { attempted: originalData.shouldSendEmail, success: false, error: null }\n  },\n  summary: {\n    totalAttempted: 0,\n    totalSuccessful: 0,\n    totalFailed: 0\n  },\n  processedAt: new Date().toISOString()\n};\n\n// 각 서비스별 결과 확인\nallInputs.forEach((input, index) => {\n  if (index === 0) return; // 첫 번째는 원본 데이터이므로 스킵\n  \n  const statusCode = input.statusCode || 0;\n  const isSuccess = statusCode >= 200 && statusCode < 300;\n  \n  // 응답 내용으로 서비스 구분\n  if (input.json && (input.json.ok !== undefined || input.json.attachments)) {\n    // Slack 응답\n    results.notifications.slack.success = isSuccess;\n    results.notifications.slack.statusCode = statusCode;\n    if (!isSuccess) {\n      results.notifications.slack.error = input.json.error || 'Slack 전송 실패';\n    }\n  } else if (statusCode === 204 || (input.json === '' && statusCode === 200)) {\n    // Discord 응답 (보통 204 No Content)\n    results.notifications.discord.success = true;\n    results.notifications.discord.statusCode = statusCode;\n  } else if (input.json && input.json.id) {\n    // Email 응답 (Resend API)\n    results.notifications.email.success = true;\n    results.notifications.email.statusCode = statusCode;\n    results.notifications.email.emailId = input.json.id;\n  } else if (statusCode >= 400) {\n    // 에러 응답 처리\n    const errorMessage = input.json?.message || input.json?.error || `HTTP ${statusCode} Error`;\n    \n    // URL로 서비스 구분\n    if (input.config?.url?.includes('slack.com')) {\n      results.notifications.slack.error = errorMessage;\n    } else if (input.config?.url?.includes('discord.com')) {\n      results.notifications.discord.error = errorMessage;\n    } else if (input.config?.url?.includes('resend.com')) {\n      results.notifications.email.error = errorMessage;\n    }\n  }\n});\n\n// 요약 계산\nObject.values(results.notifications).forEach(service => {\n  if (service.attempted) {\n    results.summary.totalAttempted++;\n    if (service.success) {\n      results.summary.totalSuccessful++;\n    } else {\n      results.summary.totalFailed++;\n    }\n  }\n});\n\n// 성공률 계산\nconst successRate = results.summary.totalAttempted > 0 \n  ? Math.round((results.summary.totalSuccessful / results.summary.totalAttempted) * 100)\n  : 0;\n\nreturn [{\n  status: 'completed',\n  results: results,\n  webhook_response: {\n    success: results.summary.totalSuccessful > 0,\n    message: `알림이 ${results.summary.totalSuccessful}/${results.summary.totalAttempted} 서비스로 전송되었습니다 (성공률: ${successRate}%)`,\n    alertId: results.alertId,\n    priority: results.priority,\n    title: results.title,\n    summary: results.summary,\n    services: {\n      slack: results.notifications.slack.attempted ? (results.notifications.slack.success ? '✅ 성공' : '❌ 실패') : '⏭️ 생략',\n      discord: results.notifications.discord.attempted ? (results.notifications.discord.success ? '✅ 성공' : '❌ 실패') : '⏭️ 생략',\n      email: results.notifications.email.attempted ? (results.notifications.email.success ? '✅ 성공' : '❌ 실패') : '⏭️ 생략'\n    }\n  }\n}];"
      },
      "id": "collect-results",
      "name": "결과 수집",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json.webhook_response }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "webhook-response",
      "name": "Webhook 응답",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1340, 300]
    }
  ],
  "connections": {
    "알림 시스템 Webhook": {
      "main": [
        [
          {
            "node": "알림 데이터 처리",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "알림 데이터 처리": {
      "main": [
        [
          {
            "node": "Slack 전송 확인",
            "type": "main",
            "index": 0
          },
          {
            "node": "Discord 전송 확인",
            "type": "main",
            "index": 0
          },
          {
            "node": "이메일 전송 확인",
            "type": "main",
            "index": 0
          },
          {
            "node": "결과 수집",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Slack 전송 확인": {
      "main": [
        [
          {
            "node": "Slack 전송",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Discord 전송 확인": {
      "main": [
        [
          {
            "node": "Discord 전송",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "이메일 전송 확인": {
      "main": [
        [
          {
            "node": "이메일 전송",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Slack 전송": {
      "main": [
        [
          {
            "node": "결과 수집",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Discord 전송": {
      "main": [
        [
          {
            "node": "결과 수집",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "이메일 전송": {
      "main": [
        [
          {
            "node": "결과 수집",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "결과 수집": {
      "main": [
        [
          {
            "node": "Webhook 응답",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
```

## 🔧 설정 방법

### 1. Slack Webhook URL 설정
1. Slack에서 Incoming Webhooks 앱을 설치합니다.
2. 채널을 선택하고 Webhook URL을 생성합니다.
3. JSON의 `YOUR_SLACK_WEBHOOK_URL`을 실제 URL로 교체합니다.

### 2. Discord Webhook URL 설정
1. Discord 서버의 채널 설정으로 이동합니다.
2. 연동 → Webhooks → 새 Webhook 생성
3. Webhook URL을 복사하여 `YOUR_DISCORD_WEBHOOK_URL`에 입력합니다.

### 3. 이메일 API 키 설정
1. [Resend](https://resend.com) 계정을 생성합니다.
2. API 키를 생성합니다.
3. `YOUR_RESEND_API_KEY`를 실제 API 키로 교체합니다.

## 🧪 테스트 방법

### curl로 테스트하기
```bash
# High Priority (모든 서비스)
curl -X POST "YOUR_N8N_WEBHOOK_URL" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "시스템 긴급 상황",
    "message": "데이터베이스 서버가 다운되었습니다",
    "priority": "high",
    "source": "DB Monitor",
    "category": "Infrastructure"
  }'

# Medium Priority (Slack + Discord)
curl -X POST "YOUR_N8N_WEBHOOK_URL" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "성능 경고",
    "message": "응답 시간이 평소보다 느립니다",
    "priority": "medium",
    "source": "APM",
    "category": "Performance"
  }'

# Low Priority (Slack만)
curl -X POST "YOUR_N8N_WEBHOOK_URL" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "정보 알림",
    "message": "일일 백업이 완료되었습니다",
    "priority": "low",
    "source": "Backup System",
    "category": "Maintenance"
  }'
```

## 📊 응답 예시
```json
{
  "success": true,
  "message": "알림이 3/3 서비스로 전송되었습니다 (성공률: 100%)",
  "alertId": "alert_1703123456789",
  "priority": "high",
  "title": "시스템 긴급 상황",
  "summary": {
    "totalAttempted": 3,
    "totalSuccessful": 3,
    "totalFailed": 0
  },
  "services": {
    "slack": "✅ 성공",
    "discord": "✅ 성공",
    "email": "✅ 성공"
  }
}
```
